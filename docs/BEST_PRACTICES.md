# Best Practices for Future Projects

> Lessons learned from SaveAFishWorks and recommendations for the next iteration.

---

## 1. Scope & Architecture

### Do One Thing Well
The SaveAFishWorks monolith tried to be a CMS, admin portal, content site, SEO engine, AND configurator in one Next.js app. This led to:
- Auth complexity (database sessions for CMS users vs the configurator's simpler needs)
- 40+ admin files that were fragile and hard to validate
- Mixing concerns: content editorial workflow has nothing in common with e-commerce configuration

**Recommendation**: Separate the **configurator** (the core value) from **content/CMS**. Use an existing CMS for content. Build the configurator as a focused, standalone tool.

### Pick the Right Platform for Each Concern

| Concern | Bad Fit | Good Fit |
|---------|---------|----------|
| Product configurator | WordPress plugin | Standalone app, Shopify app, embeddable widget |
| Content (fish profiles, guides) | Custom Next.js CMS | WordPress, Notion, Ghost, wiki platform |
| Product catalog | Custom database | Shopify (already exists) |
| User auth for CMS | NextAuth beta | CMS platform's built-in auth |
| E-commerce checkout | Custom cart | Shopify checkout (already exists) |

### Decide Early: Shopify App vs Standalone vs Widget

| Option | Pros | Cons |
|--------|------|------|
| **Native Shopify App** | Direct cart integration, Shopify admin UI, app store distribution, built-in auth | Locked to Shopify ecosystem, Shopify app review process, Polaris UI constraints |
| **Standalone (saveafish.org)** | Full control, custom UX, platform-independent | Must build auth, cart integration, hosting |
| **Embeddable Widget** | Works anywhere (Shopify, WordPress, any site), lightweight | Limited UI, iframe/shadow DOM complexity |
| **Shopify Export + Static** | Simplest, no live API dependency, works offline | Stale data, no real-time inventory, manual export |

---

## 2. Auth & User Management

### Keep Auth Simple
- Don't use beta libraries for auth (NextAuth v5 beta caused repeated issues)
- Use stable, well-documented auth solutions
- If building a Shopify app, use Shopify's built-in auth (no custom auth needed)
- If standalone, use a managed auth service (Clerk, Auth0, Supabase Auth) instead of rolling your own
- Never mix auth strategies (Credentials + OAuth + database sessions = pain)

### Auth Lessons from SaveAFishWorks
- NextAuth v5 beta: Credentials provider cannot coexist with PrismaAdapter
- `allowDangerousEmailAccountLinking` needed when migrating between auth providers
- `trustHost: true` required for localhost development
- `.env` vs `.env.local` confusion causes silent failures (empty string overrides real values)

---

## 3. Development Setup

### Zero-Config After Clone
The ideal developer experience:
```bash
git clone <repo>
cd <repo>
npm install    # postinstall handles everything
npm run dev    # works immediately
```

**What `postinstall` should handle**:
- Create env files from templates with sensible defaults
- Auto-detect system-specific values (username, paths)
- Generate secrets (AUTH_SECRET, etc.)
- Run code generation (Prisma, GraphQL codegen, etc.)
- Merge new env vars into existing files without overwriting

**What requires one-time manual setup**:
- Third-party API credentials (OAuth, Shopify tokens)
- Database creation (`createdb`)
- Nothing else

### Environment Files
- `.env.example` committed to git — the template
- `.env` and `.env.local` gitignored — generated by setup script
- **Never put empty placeholder values in `.env`** — they override `.env.local` values
- Separate concerns: `.env` for CLI tools (Prisma), `.env.local` for the app (Next.js)

---

## 4. Data Strategy

### Don't Build a CMS
Building content management (CRUD, drafts, publishing, roles, rich text editing) from scratch in Next.js is a massive undertaking that's been solved many times. Use:
- **WordPress** — if you need blog/guide content with SEO
- **Notion** — if you want a wiki-style knowledge base
- **Sanity/Contentful/Strapi** — if you want headless CMS with API access
- **Ghost** — if you want a clean publishing platform

### Shopify Is Already Your Product Database
Don't duplicate product data. Shopify's product catalog with metafields IS the database. The configurator should read from it, not maintain a parallel copy.

### Static Data as Seed, Not Source of Truth
JSON files in `src/data/` worked for prototyping but became a maintenance burden. If data needs editing, it needs a proper interface (CMS, admin UI, or Shopify metafields).

---

## 5. Code Quality

### Type Safety
- Use TypeScript strict mode
- Define clear interfaces for all data shapes
- Don't use `any` — if you don't know the type, figure it out
- Share types between frontend and backend (monorepo or shared package)

### State Management
- `useReducer` + Context worked well for the configurator — keep it
- Don't reach for Redux unless you have a clear reason
- Keep state close to where it's used
- Persist to localStorage for anonymous users, server for authenticated

### Testing
- SaveAFishWorks had zero tests — this should change
- Unit test calculator functions (substrate, bioload, compatibility)
- Integration test the Shopify API client
- E2E test the critical path: select tank → add products → checkout
- Use Vitest (fast, native ESM) or Jest

### Error Handling
- Error boundaries at route level (prevent full-page crashes)
- Graceful degradation when Shopify API is unavailable (show cached/sample data)
- Toast notifications for user-facing errors
- Structured error logging for debugging

---

## 6. Shopify Integration

### Storefront API Best Practices
- Cache product data aggressively (products don't change often)
- Check inventory in real-time (or near-real-time with short TTL)
- Handle API errors gracefully — show cached data, not error pages
- Use GraphQL fragments to avoid over-fetching
- Paginate large catalogs (cursor-based pagination)

### Metafield Strategy
- Define all metafield definitions upfront in Shopify admin
- Use the `aquascaping` namespace for all custom fields
- Make `category` and `care_level` required
- Everything else optional with sensible defaults/fallbacks
- Validate metafield data on read (don't trust it blindly)

### Cart Integration
- Use `cartCreate` and `cartLinesAdd` mutations
- Include line item properties for attribution (`_source: "configurator"`)
- Redirect to Shopify checkout — don't build custom checkout
- UTM parameters for analytics attribution

---

## 7. Performance

### Targets (from PRD)
- LCP: < 2.5s
- TTI: < 3.5s
- Product grid (50 items): < 500ms render
- Cart update: < 100ms response
- Search: < 200ms

### Strategies
- Server-side render the initial product grid
- Client-side filter/sort (no round-trip for UI state changes)
- Lazy load images (Shopify CDN handles resizing)
- Virtualize long product lists (react-window or similar)
- Debounce search input
- Cache Shopify API responses

---

## 8. Deployment

### Hetzner VPS (Not Vercel)
- Use PM2 or systemd for process management
- nginx or Caddy for reverse proxy + SSL
- Let's Encrypt for certificates
- PostgreSQL on the same VPS (or managed DB for production)
- `npm run build && npm start` for production

### CI/CD
- GitHub Actions for build validation on PR
- Auto-deploy to VPS on merge to main
- Run linting and type checking in CI
- Run tests in CI (when tests exist)

---

## 9. Project Structure Recommendations

### For a Focused Configurator App
```
src/
├── app/                    # Next.js pages
│   ├── configurator/       # Main configurator page
│   ├── api/                # API routes (Shopify proxy, logic engine)
│   └── auth/               # Auth pages (if needed)
├── components/
│   ├── configurator/       # Configurator-specific components
│   └── ui/                 # Reusable primitives
├── context/                # ConfiguratorContext
├── hooks/                  # Custom hooks
├── lib/
│   ├── shopify/            # Storefront API client
│   ├── compatibility/      # Rules engine
│   ├── calculators/        # Substrate, bioload, etc.
│   └── templates/          # Pre-built configurations
└── types/                  # TypeScript definitions
```

### What NOT to Include
- CMS/admin portal (use existing CMS)
- Content pages (fish profiles, guides — put in CMS)
- SEO infrastructure (CMS handles this)
- Email marketing integration (CMS or separate service)
- User role management beyond basic auth

---

## 10. Lessons Learned Summary

| Lesson | Impact | Recommendation |
|--------|--------|----------------|
| NextAuth v5 beta is unstable | Days of debugging auth | Use stable auth (Clerk, Supabase, or Shopify built-in) |
| Building CMS from scratch | 40+ fragile admin files | Use WordPress, Sanity, or similar |
| Monolith (CMS + configurator) | Scope creep, complexity | Separate concerns into focused apps |
| Empty env vars override real ones | Silent auth failures | Never put empty values in `.env` |
| Two dev directories | Credential sync issues | One dev directory, one source of truth |
| No tests | No confidence in changes | Test calculators, API client, critical paths |
| JSON files as data source | No editing UI, stale data | Use Shopify metafields or CMS |
| Complex conditional auth logic | Cascading failures | Keep auth dead simple, no conditionals |
